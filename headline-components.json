#!/usr/bin/env python3
"""
LUCKNOOZ Headline Generator - Version 8
Fixed proper noun detection and verb conjugation
"""

import feedparser
import json
import re
from datetime import datetime
import random

# RSS feeds
FEEDS = [
    'https://variety.com/feed/',
    'https://feeds.arstechnica.com/arstechnica/index',
    'https://feeds.bbci.co.uk/news/world/rss.xml',
    'https://feeds.npr.org/1001/rss.xml',
    'https://www.aljazeera.com/xml/rss/all.xml',
    'https://www.rollingstone.com/feed/',
    'https://www.japantimes.co.jp/feed/',
    'https://www.wired.com/feed/rss',
    'https://www.newscientist.com/feed/home',
    'https://moxie.foxnews.com/google-publisher/latest.xml',
    'https://rss.nytimes.com/services/xml/rss/nyt/HomePage.xml',
    'https://www.theguardian.com/world/rss',
    'https://www.nature.com/nature.rss',
    'http://rss.cnn.com/rss/edition.rss',
    'https://www.sciencedaily.com/rss/all.xml'
]

SKIP_PATTERNS = {
    'question_words': {'who', 'what', 'where', 'when', 'why', 'how', 'which', 'whose'},
    'determiners': {'the', 'a', 'an'},
    'problem_phrases': {
        'prime minister', 'supreme court', 'aid flotilla', 'white house',
        'best way', 'new study', 'climate change', 'human rights'
    },
    'prepositions': {
        'in', 'on', 'at', 'to', 'for', 'with', 'from', 'by', 'about',
        'as', 'into', 'through', 'during', 'before', 'after', 'above',
        'below', 'under', 'between'
    },
    'subordinating_conjunctions': {
        'that', 'which', 'who', 'whom', 'whose', 'when', 'where', 'why',
        'because', 'since', 'unless', 'although', 'though', 'while', 'if'
    }
}

# Irregular verbs with past and present forms
IRREGULAR_VERBS = {
    'is': {'singular': 'is', 'plural': 'are', 'past': 'was'},
    'are': {'singular': 'is', 'plural': 'are', 'past': 'were'},
    'was': {'singular': 'was', 'plural': 'were', 'past': 'was'},
    'were': {'singular': 'was', 'plural': 'were', 'past': 'were'},
    'has': {'singular': 'has', 'plural': 'have', 'past': 'had'},
    'have': {'singular': 'has', 'plural': 'have', 'past': 'had'},
    'had': {'singular': 'had', 'plural': 'had', 'past': 'had'},
    'does': {'singular': 'does', 'plural': 'do', 'past': 'did'},
    'do': {'singular': 'does', 'plural': 'do', 'past': 'did'},
    'did': {'singular': 'did', 'plural': 'did', 'past': 'did'},
    'goes': {'singular': 'goes', 'plural': 'go', 'past': 'went'},
    'go': {'singular': 'goes', 'plural': 'go', 'past': 'went'},
    'went': {'singular': 'went', 'plural': 'went', 'past': 'went'},
    'says': {'singular': 'says', 'plural': 'say', 'past': 'said'},
    'say': {'singular': 'says', 'plural': 'say', 'past': 'said'},
    'said': {'singular': 'said', 'plural': 'said', 'past': 'said'}
}

def clean_headline(text):
    """Clean and normalize headline text"""
    text = re.sub(r'<[^>]+>', '', text)
    text = re.sub(r'\s+', ' ', text)
    text = text.strip('"\'')
    return text.strip()

def is_past_tense(verb):
    """Check if verb is in past tense"""
    verb_lower = verb.lower()
    
    # Check irregular past tense
    past_forms = {'was', 'were', 'had', 'did', 'went', 'said', 'made', 'came', 
                  'took', 'gave', 'found', 'told', 'saw', 'knew', 'got', 'became'}
    if verb_lower in past_forms:
        return True
    
    # Regular past tense ending in -ed
    if verb_lower.endswith('ed'):
        return True
    
    return False

def is_verb_form(word):
    """Check if word looks like a verb"""
    word_lower = word.lower().strip('.,;:!?')
    
    # Auxiliary verbs
    if word_lower in ['is', 'are', 'was', 'were', 'has', 'have', 'had',
                      'will', 'would', 'can', 'could', 'may', 'might',
                      'must', 'should', 'shall', 'does', 'do', 'did']:
        return True
    
    # Common verb endings
    if (word_lower.endswith('s') or word_lower.endswith('ed') or 
        word_lower.endswith('ing')):
        # Skip nouns
        if word_lower.endswith('ness') or word_lower.endswith('ings'):
            return False
        return True
    
    return False

def find_main_verb(title):
    """Find the MAIN verb, rejecting problematic patterns"""
    words = title.split()
    
    # REJECT: Question words at start
    if words and words[0].lower() in SKIP_PATTERNS['question_words']:
        return -1
    
    # REJECT: "How to" patterns
    if len(words) >= 2 and words[0].lower() == 'how' and words[1].lower() == 'to':
        return -1
    
    # REJECT: Headlines starting with gerund
    if words and words[0].endswith('ing'):
        return -1
    
    in_subordinate = False
    after_comma = False
    
    for i, word in enumerate(words):
        word_lower = word.lower().strip('.,;:!?')
        
        # Check for comma
        if ',' in word:
            after_comma = True
            continue
        
        # Check for subordinating conjunction
        if word_lower in SKIP_PATTERNS['subordinating_conjunctions']:
            in_subordinate = True
            continue
        
        # Skip problem phrases
        if i < 3:
            phrase = ' '.join(w.lower() for w in words[max(0, i-2):i+2])
            if any(problem in phrase for problem in SKIP_PATTERNS['problem_phrases']):
                continue
        
        # Skip if preceded by determiner
        if i > 0 and words[i-1].lower() in SKIP_PATTERNS['determiners']:
            continue
        
        # Skip if preceded by preposition
        if i > 0 and words[i-1].lower() in SKIP_PATTERNS['prepositions']:
            continue
        
        # Check if this looks like a verb
        if is_verb_form(word):
            if i > 0 and not in_subordinate and not after_comma:
                return i
            elif after_comma and i <= 5:
                return i
    
    return -1

def is_plural_subject(subject):
    """
    Determine if subject is plural or singular
    CRITICAL: Proper nouns are ALWAYS singular
    """
    subject_lower = subject.lower().strip()
    words = subject.split()
    
    if not words:
        return False
    
    # Check for compound subjects with "and"
    if ' and ' in subject_lower:
        return True
    
    # Plural determiners/quantifiers
    plural_markers = {'these', 'those', 'many', 'several', 'few', 'both', 'all'}
    if words[0].lower() in plural_markers:
        return True
    
    # CRITICAL: Check if subject is a proper noun (capitalized)
    # Count capitalized words (excluding articles at start)
    start_index = 0
    if words[0].lower() in {'the', 'a', 'an'}:
        start_index = 1
    
    if start_index < len(words):
        # Check if we have capitalized words (proper nouns)
        capitalized_words = [w for w in words[start_index:] if w and w[0].isupper()]
        
        # If we have any capitalized words, treat as singular
        # (Trump, Google, Charlie Sheen, Las Vegas Sands, etc.)
        if capitalized_words:
            return False
    
    # Check last word for plural ending
    last_word = words[-1].strip('.,;:!?').lower()
    
    # Common plural endings
    if last_word.endswith('s') and not last_word.endswith('ss'):
        # But check if it's a verb form or singular noun
        if last_word in {'news', 'us', 'virus', 'lens', 'caucus'}:
            return False
        return True
    
    # Default to singular
    return False

def conjugate_verb(verb, subject, original_verb):
    """
    Conjugate verb to match subject
    Preserves past tense from original
    """
    is_plural = is_plural_subject(subject)
    verb_lower = verb.lower().strip('.,;:!?')
    original_lower = original_verb.lower().strip('.,;:!?')
    
    # Check if original verb was past tense
    was_past_tense = is_past_tense(original_lower)
    
    # Handle verb phrases (e.g., "opens up", "is preparing")
    verb_parts = verb.split()
    
    if len(verb_parts) > 1:
        # Multi-word verb phrase
        first_word = verb_parts[0].lower().strip('.,;:!?')
        
        if first_word in IRREGULAR_VERBS:
            if was_past_tense:
                verb_parts[0] = IRREGULAR_VERBS[first_word]['past']
            elif is_plural:
                verb_parts[0] = IRREGULAR_VERBS[first_word]['plural']
            else:
                verb_parts[0] = IRREGULAR_VERBS[first_word]['singular']
        
        return ' '.join(verb_parts)
    
    # Single word verb
    if verb_lower in IRREGULAR_VERBS:
        if was_past_tense:
            return IRREGULAR_VERBS[verb_lower]['past']
        elif is_plural:
            return IRREGULAR_VERBS[verb_lower]['plural']
        else:
            return IRREGULAR_VERBS[verb_lower]['singular']
    
    # Regular verbs
    if was_past_tense:
        # Keep past tense (most regular verbs end in -ed)
        return verb
    
    if is_plural:
        # Plural: remove -s/-es
        if verb_lower.endswith('ies'):
            return verb_lower[:-3] + 'y'
        elif verb_lower.endswith('es'):
            if verb_lower.endswith(('shes', 'ches', 'xes', 'zes', 'oes')):
                return verb_lower[:-2]
            return verb_lower[:-1]
        elif verb_lower.endswith('s') and not verb_lower.endswith('ss'):
            return verb_lower[:-1]
        return verb
    else:
        # Singular: add -s/-es
        if verb_lower.endswith(('s', 'x', 'z', 'ch', 'sh', 'o')):
            return verb + 'es'
        elif verb_lower.endswith('y') and len(verb_lower) > 1 and verb_lower[-2] not in 'aeiou':
            return verb_lower[:-1] + 'ies'
        elif not verb_lower.endswith('s'):
            return verb + 's'
        return verb

def parse_headline(title, source):
    """Parse headline into subject and predicate"""
    title = clean_headline(title)
    
    # Skip if too short
    if len(title.split()) < 4:
        return None
    
    # Find main verb
    verb_pos = find_main_verb(title)
    
    if verb_pos < 1:  # Need at least one word before verb
        return None
    
    words = title.split()
    
    # Extract subject and predicate
    subject_words = words[:verb_pos]
    predicate_words = words[verb_pos:]
    
    subject = ' '.join(subject_words)
    predicate = ' '.join(predicate_words)
    verb = words[verb_pos]
    
    # Quality checks
    if len(subject.split()) < 2:  # Subject too short
        return None
    
    if len(subject.split()) > 15:  # Subject too long
        return None
    
    return {
        'subject': subject,
        'verb': verb,
        'predicate': predicate,
        'original': title,
        'source': source
    }

def fetch_headlines():
    """Fetch headlines from all RSS feeds"""
    all_headlines = []
    
    print("Fetching headlines from feeds...")
    
    for feed_url in FEEDS:
        try:
            print(f"  Fetching from {feed_url}...")
            feed = feedparser.parse(feed_url)
            source = feed.feed.get('title', feed_url)
            
            for entry in feed.entries[:30]:
                title = entry.get('title', '')
                if title:
                    parsed = parse_headline(title, source)
                    if parsed:
                        all_headlines.append(parsed)
            
            print(f"    Found {len([h for h in all_headlines if h['source'] == source])} parseable headlines")
        
        except Exception as e:
            print(f"    Error fetching {feed_url}: {str(e)}")
    
    return all_headlines

def generate_combinations(headlines, num_combinations=100):
    """Generate new headline combinations from different sources"""
    if len(headlines) < 2:
        return []
    
    combinations = []
    attempts = 0
    max_attempts = num_combinations * 10
    
    while len(combinations) < num_combinations and attempts < max_attempts:
        attempts += 1
        
        # Pick random subject and predicate
        subj_headline = random.choice(headlines)
        pred_headline = random.choice(headlines)
        
        # CRITICAL: Ensure different originals
        if subj_headline['original'] == pred_headline['original']:
            continue
        
        # Create new headline
        subject = subj_headline['subject']
        predicate = pred_headline['predicate']
        verb = pred_headline['verb']
        original_verb = pred_headline['verb']
        
        # Conjugate verb to match new subject
        conjugated_verb = conjugate_verb(verb, subject, original_verb)
        
        # Replace the verb in the predicate
        predicate_words = predicate.split()
        if predicate_words:
            predicate_words[0] = conjugated_verb
        new_predicate = ' '.join(predicate_words)
        
        new_headline = f"{subject} {new_predicate}"
        
        # Check for duplicates
        if any(c['headline'] == new_headline for c in combinations):
            continue
        
        combinations.append({
            'headline': new_headline,
            'subject': {
                'text': subject,
                'original': subj_headline['original'],
                'source': subj_headline['source']
            },
            'predicate': {
                'text': new_predicate,
                'original': pred_headline['original'],
                'source': pred_headline['source']
            }
        })
    
    print(f"Generated {len(combinations)} unique combinations from {len(headlines)} parsed headlines")
    return combinations

def main():
    print("=" * 60)
    print("LUCKNOOZ Headline Generator v8")
    print("=" * 60)
    print()
    
    # Fetch and parse headlines
    headlines = fetch_headlines()
    
    if not headlines:
        print("ERROR: No headlines parsed successfully")
        return
    
    print()
    print(f"Successfully parsed {len(headlines)} headlines")
    print()
    
    # Generate combinations
    combinations = generate_combinations(headlines, num_combinations=100)
    
    if not combinations:
        print("ERROR: Could not generate any combinations")
        return
    
    # Prepare output
    output = {
        'generated': datetime.now().isoformat(),
        'total_headlines': len(combinations),
        'headlines': combinations
    }
    
    # Save to file
    filename = 'headline-components.json'
    with open(filename, 'w', encoding='utf-8') as f:
        json.dump(output, f, indent=2, ensure_ascii=False)
    
    print(f"✅ Saved {len(combinations)} new headlines to {filename}")
    print()
    print("Sample headlines:")
    for combo in combinations[:5]:
        print(f"  • {combo['headline']}")
    print()
    print("Upload headline-components.json to GitHub to update your site!")

if __name__ == "__main__":
    main()
