#!/usr/bin/env python3
"""
LUCKNOOZ Headline Generator - Version 7
Improved verb detection and conjugation
Prevents same-source combinations
"""

import feedparser
import json
import re
from datetime import datetime
import random

# RSS feeds - your selected 15
FEEDS = [
    'https://variety.com/feed/',
    'https://feeds.arstechnica.com/arstechnica/index',
    'https://feeds.bbci.co.uk/news/world/rss.xml',
    'https://feeds.npr.org/1001/rss.xml',
    'https://www.aljazeera.com/xml/rss/all.xml',
    'https://www.rollingstone.com/feed/',
    'https://www.japantimes.co.jp/feed/',
    'https://www.wired.com/feed/rss',
    'https://www.newscientist.com/feed/home',
    'https://moxie.foxnews.com/google-publisher/latest.xml',
    'https://rss.nytimes.com/services/xml/rss/nyt/HomePage.xml',
    'https://www.theguardian.com/world/rss',
    'https://www.nature.com/nature.rss',
    'http://rss.cnn.com/rss/edition.rss',
    'https://www.sciencedaily.com/rss/all.xml'
]

# Words to skip - these indicate the verb we found is NOT the main verb
SKIP_PATTERNS = {
    'question_words': {'who', 'what', 'where', 'when', 'why', 'how', 'which', 'whose'},
    'determiners': {'the', 'a', 'an'},
    'problem_phrases': {
        'prime minister', 'supreme court', 'aid flotilla', 'white house',
        'best way', 'new study', 'climate change', 'human rights'
    },
    'prepositions': {
        'in', 'on', 'at', 'to', 'for', 'with', 'from', 'by', 'about',
        'as', 'into', 'through', 'during', 'before', 'after', 'above',
        'below', 'under', 'between'
    },
    'subordinating_conjunctions': {
        'that', 'which', 'who', 'whom', 'whose', 'when', 'where', 'why',
        'because', 'since', 'unless', 'although', 'though', 'while', 'if'
    }
}

# Common irregular verbs
IRREGULAR_VERBS = {
    'is': {'singular': 'is', 'plural': 'are'},
    'are': {'singular': 'is', 'plural': 'are'},
    'was': {'singular': 'was', 'plural': 'were'},
    'were': {'singular': 'was', 'plural': 'were'},
    'has': {'singular': 'has', 'plural': 'have'},
    'have': {'singular': 'has', 'plural': 'have'},
    'does': {'singular': 'does', 'plural': 'do'},
    'do': {'singular': 'does', 'plural': 'do'},
    'goes': {'singular': 'goes', 'plural': 'go'},
    'go': {'singular': 'goes', 'plural': 'go'},
    'says': {'singular': 'says', 'plural': 'say'},
    'say': {'singular': 'says', 'plural': 'say'}
}

def clean_headline(text):
    """Clean and normalize headline text"""
    # Remove HTML tags
    text = re.sub(r'<[^>]+>', '', text)
    # Normalize whitespace
    text = re.sub(r'\s+', ' ', text)
    # Remove quotes
    text = text.strip('"\'')
    return text.strip()

def is_verb_form(word):
    """Check if word looks like a verb"""
    word_lower = word.lower()
    
    # Auxiliary verbs
    if word_lower in ['is', 'are', 'was', 'were', 'has', 'have', 'had',
                      'will', 'would', 'can', 'could', 'may', 'might',
                      'must', 'should', 'shall', 'does', 'do', 'did']:
        return True
    
    # Common verb endings
    if (word_lower.endswith('s') or word_lower.endswith('ed') or 
        word_lower.endswith('ing')):
        # But skip if it's a noun (rough heuristic)
        if word_lower.endswith('ness') or word_lower.endswith('ings'):
            return False
        return True
    
    return False

def find_main_verb(title):
    """
    Find the MAIN verb in the headline
    Skip verbs in subordinate clauses, after commas, etc.
    """
    words = title.split()
    
    # Skip questions entirely
    if words and words[0].lower() in SKIP_PATTERNS['question_words']:
        return -1
    
    # Skip if starts with gerund
    if words and words[0].endswith('ing'):
        return -1
    
    # Track depth of subordinate clauses
    in_subordinate = False
    after_comma = False
    
    for i, word in enumerate(words):
        word_lower = word.lower().strip('.,;:!?')
        
        # Check for comma (often introduces subordinate info)
        if ',' in word:
            after_comma = True
            continue
        
        # Check for subordinating conjunction
        if word_lower in SKIP_PATTERNS['subordinating_conjunctions']:
            in_subordinate = True
            continue
        
        # Skip first few words if they form problem phrases
        if i < 3:
            phrase = ' '.join(w.lower() for w in words[max(0, i-2):i+2])
            if any(problem in phrase for problem in SKIP_PATTERNS['problem_phrases']):
                continue
        
        # Skip if preceded by determiner
        if i > 0 and words[i-1].lower() in SKIP_PATTERNS['determiners']:
            continue
        
        # Skip if preceded by preposition
        if i > 0 and words[i-1].lower() in SKIP_PATTERNS['prepositions']:
            continue
        
        # Check if this looks like a verb
        if is_verb_form(word):
            # If we're not in a subordinate clause and not after a comma
            # AND we have at least one word before this as the subject
            if i > 0 and not in_subordinate and not after_comma:
                return i
            # If we're after a comma, this might still be the main verb
            # if it's early in the sentence (within first 5 words)
            elif after_comma and i <= 5:
                return i
    
    return -1

def is_plural_subject(subject):
    """Determine if subject is plural or singular"""
    subject_lower = subject.lower().strip()
    words = subject_lower.split()
    
    if not words:
        return False
    
    last_word = words[-1].strip('.,;:!?')
    
    # Explicit plural markers
    if last_word.endswith('s') and not last_word.endswith('ss'):
        # But not if it's a proper noun ending in s
        if words[-1][0].isupper():
            return False
        return True
    
    # Plural determiners
    plural_determiners = {'these', 'those', 'many', 'several', 'few', 'both'}
    if words[0] in plural_determiners:
        return True
    
    # Compound subjects (X and Y)
    if ' and ' in subject_lower:
        return True
    
    # Countries, organizations, people names are singular
    if words[-1][0].isupper():
        return False
    
    # Default to singular
    return False

def conjugate_verb(verb, subject):
    """
    Conjugate verb to match subject
    Handles verb phrases like "was able to" or "has been"
    """
    is_plural = is_plural_subject(subject)
    verb_lower = verb.lower()
    
    # Handle verb phrases (auxiliary + main verb)
    verb_parts = verb.split()
    
    if len(verb_parts) > 1:
        # Multi-word verb phrase
        first_word = verb_parts[0].lower()
        
        if first_word in IRREGULAR_VERBS:
            if is_plural:
                verb_parts[0] = IRREGULAR_VERBS[first_word]['plural']
            else:
                verb_parts[0] = IRREGULAR_VERBS[first_word]['singular']
            
            # Handle "to" + verb (infinitive)
            if len(verb_parts) > 2 and verb_parts[1] == 'to':
                # "was able to transmit" -> keep infinitive form
                pass
            elif len(verb_parts) > 1:
                # Fix past participles if needed
                last_word = verb_parts[-1]
                if last_word.endswith('ed') or last_word.endswith('ing'):
                    pass  # Keep participles as-is
        
        return ' '.join(verb_parts)
    
    # Single word verb
    if verb_lower in IRREGULAR_VERBS:
        if is_plural:
            return IRREGULAR_VERBS[verb_lower]['plural']
        else:
            return IRREGULAR_VERBS[verb_lower]['singular']
    
    # Regular verb conjugation
    if is_plural:
        # Plural: remove -s/-es
        if verb_lower.endswith('ies'):
            return verb_lower[:-3] + 'y'
        elif verb_lower.endswith('es'):
            if verb_lower.endswith(('shes', 'ches', 'xes', 'zes', 'oes')):
                return verb_lower[:-2]
            return verb_lower[:-1]
        elif verb_lower.endswith('s') and not verb_lower.endswith('ss'):
            return verb_lower[:-1]
        return verb
    else:
        # Singular: add -s/-es
        if verb_lower.endswith(('s', 'x', 'z', 'ch', 'sh')):
            return verb + 'es'
        elif verb_lower.endswith('y') and len(verb_lower) > 1 and verb_lower[-2] not in 'aeiou':
            return verb_lower[:-1] + 'ies'
        elif not verb_lower.endswith('s'):
            return verb + 's'
        return verb

def parse_headline(title, source):
    """Parse headline into subject and predicate"""
    title = clean_headline(title)
    
    # Skip if too short
    if len(title.split()) < 4:
        return None
    
    # Find main verb
    verb_pos = find_main_verb(title)
    
    if verb_pos < 1:  # Need at least one word before verb
        return None
    
    words = title.split()
    
    # Extract subject and predicate
    subject_words = words[:verb_pos]
    predicate_words = words[verb_pos:]
    
    subject = ' '.join(subject_words)
    predicate = ' '.join(predicate_words)
    verb = words[verb_pos]
    
    # Quality checks
    if len(subject.split()) < 2:  # Subject too short
        return None
    
    if len(subject.split()) > 15:  # Subject too long
        return None
    
    return {
        'subject': subject,
        'verb': verb,
        'predicate': predicate,
        'original': title,
        'source': source
    }

def fetch_headlines():
    """Fetch headlines from all RSS feeds"""
    all_headlines = []
    
    print("Fetching headlines from feeds...")
    
    for feed_url in FEEDS:
        try:
            print(f"  Fetching from {feed_url}...")
            feed = feedparser.parse(feed_url)
            source = feed.feed.get('title', feed_url)
            
            for entry in feed.entries[:30]:  # Get up to 30 from each
                title = entry.get('title', '')
                if title:
                    parsed = parse_headline(title, source)
                    if parsed:
                        all_headlines.append(parsed)
            
            print(f"    Found {len([h for h in all_headlines if h['source'] == source])} parseable headlines")
        
        except Exception as e:
            print(f"    Error fetching {feed_url}: {str(e)}")
    
    return all_headlines

def generate_combinations(headlines, num_combinations=100):
    """
    Generate new headline combinations
    CRITICAL: Ensure subject and predicate come from DIFFERENT sources
    """
    if len(headlines) < 2:
        return []
    
    combinations = []
    attempts = 0
    max_attempts = num_combinations * 10  # Try up to 10x to get enough unique combinations
    
    while len(combinations) < num_combinations and attempts < max_attempts:
        attempts += 1
        
        # Pick random subject and predicate
        subj_headline = random.choice(headlines)
        pred_headline = random.choice(headlines)
        
        # CRITICAL: Ensure they're from different original headlines
        if subj_headline['original'] == pred_headline['original']:
            continue  # Skip same-source combinations
        
        # Create new headline
        subject = subj_headline['subject']
        predicate = pred_headline['predicate']
        verb = pred_headline['verb']
        
        # Conjugate verb to match new subject
        conjugated_verb = conjugate_verb(verb, subject)
        
        # Replace the verb in the predicate
        predicate_words = predicate.split()
        if predicate_words:
            predicate_words[0] = conjugated_verb
        new_predicate = ' '.join(predicate_words)
        
        new_headline = f"{subject} {new_predicate}"
        
        # Check if we already have this combination
        if any(c['headline'] == new_headline for c in combinations):
            continue
        
        combinations.append({
            'headline': new_headline,
            'subject': {
                'text': subject,
                'original': subj_headline['original'],
                'source': subj_headline['source']
            },
            'predicate': {
                'text': new_predicate,
                'original': pred_headline['original'],
                'source': pred_headline['source']
            }
        })
    
    print(f"Generated {len(combinations)} unique combinations from {len(headlines)} parsed headlines")
    return combinations

def main():
    print("=" * 60)
    print("LUCKNOOZ Headline Generator v7")
    print("=" * 60)
    print()
    
    # Fetch and parse headlines
    headlines = fetch_headlines()
    
    if not headlines:
        print("ERROR: No headlines parsed successfully")
        return
    
    print()
    print(f"Successfully parsed {len(headlines)} headlines")
    print()
    
    # Generate combinations
    combinations = generate_combinations(headlines, num_combinations=100)
    
    if not combinations:
        print("ERROR: Could not generate any combinations")
        return
    
    # Prepare output
    output = {
        'generated': datetime.now().isoformat(),
        'total_headlines': len(combinations),
        'headlines': combinations
    }
    
    # Save to file
    filename = 'headline-components.json'
    with open(filename, 'w', encoding='utf-8') as f:
        json.dump(output, f, indent=2, ensure_ascii=False)
    
    print(f"✅ Saved {len(combinations)} new headlines to {filename}")
    print()
    print("Sample headlines:")
    for combo in combinations[:5]:
        print(f"  • {combo['headline']}")
    print()
    print("Upload headline-components.json to GitHub to update your site!")

if __name__ == "__main__":
    main()
